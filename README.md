# OOD Study

## 1. 概要

2021年6月26日(土) DT勉強会<br>
「DDDに入門するためのオブジェクト指向設計(OOD)」

- インプット：サンプルコードを見ながらOODの設計原則を紹介
- アウトプット：仕様変更に合わせて設計を変えてみる

## 2. サンプルコード

### 2-1. setup

```bash
git clone https://github.com/dt30harada/ood-study.git
cd ./ood-study
cp .env.example .env

# 以下 Docker Desktop for Mac を使用する場合
./dockcom.sh start
./dockcom.sh composer install
# テスト実行 (自動的にDBに初期データが格納されます)
./dockcom.sh artisan test ./tests/Feature/OrderTest.php
```

### 2-2. ECサイト注文処理API

項目|内容
:---:|---
ユースケース|商品を注文する
アクター|顧客
事前条件|注文日時、顧客、商品×個数のリストが特定されている
事後条件|注文情報が画面に表示されている<br>注文情報がストレージに保存されている
トリガー|商品と個数を選択し、注文するボタンを押す
基本パス|1. 注文情報を作成する<br>1-1. 商品ごとの注文額を算出する<br>1-2. 小計を算出する<br>1-3. 割引額を算出する<br>1-4. 送料を算出する<br>1-5. 総計を算出する<br>2. 注文情報を保存する<br>3. 決済処理を実行する<br>4. 注文情報を表示する
例外パス|注文情報の保存処理や決済処理に失敗した場合は、その旨を表示する
備考|在庫は考慮しない<br>消費税は一律10%

■ 2段階の顧客ランク制
ルール|一般|VIP
:---:|:---:|:---:
割引|注文日に7がつく日なら小計(税抜)の5%|常に小計(税抜)の5%
送料|一律500円<br>小計(税抜)が5,000円以上なら無料|常に無料

## 3. オブジェクト指向の基本概念

- カプセル化（情報隠蔽）
- 継承（is-a）
- ポリモーフィズム（多態性）
- 集約/コンポジション（has-a）

「継承」より「集約」を重視する傾向

## 4. プログラミングパラダイム

→ [猫型プログラミング言語史観(1) 〜あるいはオブジェクト指向における設計指針のひとつ〜](https://nekogata.hatenablog.com/entry/2014/01/17/125600)<br>
→ [新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡](https://qiita.com/hirokidaichi/items/591ad96ab12938878fe1)<br>

### 4-1. 手続き型（構造化プログラミング？）

- データと処理を分ける
- トップダウンで処理の流れを記述していく
- 機能単位でモジュールを分割する
- トランザクションスクリプトパターン

### 4-2. オブジェクト指向

- データと処理をまとめる
- 責務(役割)単位でモジュール(クラス)を分割する
- オブジェクト同士の相互作用によってシステムを構築していく
- ドメインモデルパターン

### 注意

手続き型とオブジェクト指向、どちらが優れているかはケースバイケース<br>
「設計はトレードオフ」「YAGNI」「KISS原則」<br>
ビジネスロジックが複雑であり、仕様変更が多く変更容易性が求められるケースではオブジェクト指向設計を意識してみる

→ [FizzBuzzエンタープライズ版](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)<br>
→ [5年間 Laravel を使って辿り着いた，全然頑張らない「なんちゃってクリーンアーキテクチャ」という落としどころ](https://zenn.dev/mpyw/articles/ce7d09eb6d8117)<br>
→ [より良いトランザクションスクリプトを目指す](https://enrike3.hatenablog.com/entry/2019/12/28/002201)<br>

## 5. オブジェクト指向設計の原則（SOLID原則）

柔軟に変更に対応できるクラス設計のための視点を提供する5つの原則

→ [Laravelのコードで学ぶSOLID原則](https://kyamashiro.hateblo.jp/entry/2020/02/09/124714)<br>

### 5-1. 単一責任原則 (Single Responsibility Principle : SRP)

項目|内容
:---:|---
概要|1つのクラスにつき変更理由（役割）は1つだけ
メリット|変更箇所を特定しやすい、コンフリクト防止、単独デプロイ可
デメリット|クラス数の増加
備考|2つの役割が必ず同時に変更されるようなケースでは分離すると不要な複雑さをもたらす（『アジャイルソフトウェア開発の奥義』p.124）

→ [プログラマが知るべき97のこと.com/エッセイ/単一責任原則](https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com/%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4/%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E5%8E%9F%E5%89%87/)<br>
→ [単一責任原則で無責任な多目的クラスを爆殺する](https://qiita.com/MinoDriven/items/76307b1b066467cbfd6a)<br>
→ [役割駆動設計で巨大クラスを爆殺する](https://qiita.com/MinoDriven/items/2a378a09638e234d8614)<br>

■ 役割の最小単位: 値オブジェクトにビジネスロジックを凝集させる

→ [設計要件をギッチギチに詰めたValueObjectで低凝集クラスを爆殺する](https://qiita.com/MinoDriven/items/5e69d9bd028aa350e2c4)<br>

■ レイヤードアーキテクチャを通して役割(関心事)の分離を意識する

→ [Laravelで実践アーキテクチャ](https://qiita.com/nrslib/items/aa49d10dd2bcb3110f22)<br>
→ [新卒にも伝わるドメイン駆動設計のアーキテクチャ説明](https://little-hands.hatenablog.com/entry/2018/12/10/ddd-architecture)<br>

### 5-2. 開放・閉鎖原則 (OCP: Open Closed Principle)

#### 概要

- 「拡張に対して開かれ、修正に対して閉じた」クラス設計
- 既存のコードを修正することなく、コードの新規追加によって変更に対応する

#### 実現方法・キーワード

- 「DI」「抽象に依存する」「ポリモーフィズム」「ストラテジーパターン」
- 「LSP」に注意

### 5-3. リスコフの置換原則 (LSP: Liskov Substitution Principle)

- 「基底型(スーパークラス)は派生型(サブクラス)で置換可能でなければならない」
- 継承の乱用を防ぎ、抽象に対するプログラミングを促す
- OCP準拠の前提

→ [「契約による設計」との関連](https://qiita.com/hiko1129/items/9b3066feffabccf83c16)<br>

■ 契約による設計（DbC）について

→ [PHP7で堅牢なコードを書く - 例外処理、表明プログラミング、契約による設計](https://speakerdeck.com/twada/php-conference-2016?slide=90)<br>
→ [要求型の関数と保護型の関数|契約による設計の紹介](https://speakerdeck.com/hakobe/qi-yue-niyorushe-ji-falseshao-jie?slide=24)<br>

### 5-4. インターフェイス分離原則 (ISP: Interface Segregation Principle)

- クライアントにとって不要なメソッドへの依存を強制してはならない
- SRPのインターフェイス版

### 5-5. 依存関係逆転原則（DIP: Dependency Inversion Principle）

1. 上位モジュールは下位モジュールに依存してはならず、どちらも抽象に依存すべき
2. 抽象は実装に依存してはならず、実装の詳細が抽象に依存すべき

- 処理の方向と依存の方向を反転させる
- 抽象に依存する
- 特にビジネスロジックがDB等の永続化層といった「技術詳細」レイヤーに依存することを避ける
- クリーンアキテクチャの同心円

→ [10年先を見据えて作る PHP WEBアプリケーション設計入門](https://speakerdeck.com/nrslib/introduction-to-web-application-design)<br>

## 6. アウトプット

サンプルコードの割引額計算ルールについて、以下のような仕様変更に対応してみる
### 6-1. 顧客ランクだけでなく年齢区分も追加された場合

年齢＼ランク|一般|VIP
:---:|---|---
65歳以上|常に小計(税抜)の5%|常に小計(税抜)の10%
65歳未満|注文日に7がつく日なら小計(税抜)の5%|常に小計(税抜)の5%

### 6-2. 複数の割引ルールに該当する場合

各ルールは排他的で優先度に従い適用される場合、これをどのようにコード上で表現するか

- <優先度 高> 注文日が誕生日なら小計(税抜)の50%
- <優先度 中> 注文日に7がつく日は小計(税抜)の10%
- <優先度 低> 65歳以上で小計(税抜)が3万円以上なら小計(税抜)の10%
